{"version":3,"sources":["index.js","lib/index.js","lib/configure.js","lib/handle/index.js","lib/handle/blockquote.js","lib/util/container-flow.js","lib/util/indent-lines.js","lib/handle/break.js","lib/util/pattern-in-scope.js","lib/handle/code.js","lib/util/format-code-as-indented.js","lib/util/check-fence.js","lib/util/safe.js","lib/util/pattern-compile.js","lib/handle/definition.js","lib/util/association.js","lib/util/check-quote.js","lib/handle/emphasis.js","lib/util/check-emphasis.js","lib/util/container-phrasing.js","lib/handle/heading.js","lib/util/format-heading-as-setext.js","lib/handle/html.js","lib/handle/image.js","lib/handle/image-reference.js","lib/handle/inline-code.js","lib/handle/link.js","lib/util/format-link-as-autolink.js","lib/handle/link-reference.js","lib/handle/list.js","lib/handle/list-item.js","lib/util/check-bullet.js","lib/util/check-list-item-indent.js","lib/handle/paragraph.js","lib/handle/root.js","lib/handle/strong.js","lib/util/check-strong.js","lib/handle/text.js","lib/handle/thematic-break.js","lib/util/check-rule-repeat.js","lib/util/check-rule.js","lib/join.js","lib/unsafe.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;;ACDA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA;ACFA,AENA,ADGA,AFMA,AIZA;AHUA,AENA,ADGA,AFMA,AIZA;AHUA,AENA,ADGA,AFMA,AIZA;AHUA,AENA,ADGA,AFMA,AIZA,ACHA;AJaA,AENA,ADGA,AFMA,AIZA,ACHA;AJaA,AENA,ADGA,AFMA,AIZA,ACHA;AJaA,AENA,AGTA,AJYA,AFMA,AIZA,ACHA;AJaA,AENA,AGTA,AJYA,AFMA,AIZA,ACHA;AJaA,AENA,AGTA,AJYA,AFMA,AIZA,ACHA;AJaA,AENA,AGTA,AJYA,AFMA,AIZA,ACHA,AENA;ANmBA,AENA,AGTA,AJYA,AFMA,AIZA,ACHA,AENA;ANmBA,AENA,AGTA,AJYA,AFMA,AIZA,ACHA,AENA;ANmBA,AENA,AGTA,AENA,ANkBA,AFMA,AIZA,ACHA,AENA;ANmBA,AKfA,AENA,ANkBA,AFMA,AIZA,ACHA,AENA;ANmBA,AKfA,AENA,ANkBA,AFMA,AIZA,ACHA,AENA;ANmBA,AKfA,AENA,ARwBA,AIZA,AKfA,AJYA,AENA;ANmBA,AKfA,AENA,ARwBA,AIZA,AKfA,AJYA,AENA;ANmBA,AKfA,AENA,ARwBA,AIZA,AKfA,AJYA,AENA;ANmBA,AKfA,AENA,ARwBA,AU9BA,ANkBA,AKfA,AJYA,AENA;ADIA,AENA,ARwBA,AU9BA,ANkBA,AKfA,AJYA,AENA;ADIA,AENA,ARwBA,AU9BA,ANkBA,AKfA,AJYA,AENA;ADIA,AENA,ARwBA,AU9BA,ANkBA,AKfA,AJYA,AENA,AIZA;ALgBA,AENA,ARwBA,AU9BA,ANkBA,AKfA,AJYA,AENA,AIZA;ALgBA,AENA,ARwBA,AU9BA,ANkBA,AKfA,AJYA,AENA,AIZA;ALgBA,AENA,ARwBA,AU9BA,ANkBA,AKfA,AJYA,AOrBA,ALeA,AIZA;ALgBA,AENA,ARwBA,AU9BA,ANkBA,AKfA,AJYA,AOrBA,ALeA,AIZA;ALgBA,AENA,ARwBA,AU9BA,ANkBA,AKfA,AJYA,AOrBA,ALeA,AIZA;AHUA,AKfA,AbuCA,AU9BA,ANkBA,AKfA,AJYA,AOrBA,ALeA,AIZA;AHUA,AKfA,AbuCA,AU9BA,ANkBA,AKfA,AJYA,AOrBA,ALeA,AIZA;AHUA,AKfA,AbuCA,AU9BA,ANkBA,AKfA,AGTA,ALeA,AIZA;AHUA,AKfA,AbuCA,Ac1CA,AJYA,ANkBA,AQxBA,ALeA,AIZA;AHUA,AKfA,AbuCA,Ac1CA,AJYA,ANkBA,AQxBA,ALeA,AIZA;AHUA,AKfA,AbuCA,Ac1CA,AJYA,ANkBA,AQxBA,ALeA,AIZA;AHUA,AKfA,AbuCA,Ac1CA,AJYA,AKfA,AXiCA,AQxBA,ALeA,AIZA;AHUA,AKfA,AbuCA,Ac1CA,ACHA,AXiCA,AQxBA,ALeA,AIZA;AHUA,AKfA,AbuCA,Ac1CA,ACHA,AXiCA,AQxBA,ALeA,AIZA;AHUA,AKfA,AGTA,AhBgDA,Ac1CA,ACHA,AXiCA,AQxBA,ALeA,AIZA;AHUA,AKfA,AGTA,AhBgDA,Ac1CA,ACHA,AXiCA,AQxBA,ALeA,AIZA;AHUA,AKfA,AGTA,AhBgDA,Ac1CA,ACHA,AXiCA,AQxBA,ALeA,AIZA;AHUA,AKfA,AGTA,AhBgDA,Ac1CA,AGTA,AFMA,AXiCA,AQxBA,ALeA,AIZA;AHUA,AKfA,AGTA,AhBgDA,Ac1CA,AGTA,AFMA,AXiCA,AQxBA,ADGA;AHUA,AKfA,AGTA,AhBgDA,Ac1CA,AGTA,AFMA,AXiCA,AQxBA,ADGA;AHUA,AKfA,AGTA,AhBgDA,Ac1CA,AGTA,AFMA,AXiCA,Ac1CA,ANkBA,ADGA;AHUA,AKfA,AGTA,AhBgDA,Ac1CA,AGTA,AFMA,AXiCA,Ac1CA,ANkBA,ADGA;AHUA,AKfA,AGTA,AhBgDA,Ac1CA,AGTA,AFMA,AXiCA,Ac1CA,ANkBA,ADGA;AHUA,AKfA,AGTA,AGTA,AnByDA,Ac1CA,AGTA,AFMA,AXiCA,Ac1CA,ANkBA,ADGA;AHUA,AKfA,AGTA,AGTA,AnByDA,Ac1CA,AGTA,AFMA,AXiCA,Ac1CA,ANkBA,ADGA;AHUA,AKfA,AGTA,AGTA,AnByDA,Ac1CA,AGTA,AFMA,AXiCA,Ac1CA,ANkBA,ADGA;AHUA,AKfA,AGTA,AGTA,AnByDA,Ac1CA,AGTA,AFMA,AGTA,AENA,ARwBA,ADGA;AHUA,AKfA,AGTA,AGTA,AnByDA,Ac1CA,AGTA,ACHA,AENA,ARwBA,ADGA;AHUA,AKfA,AGTA,AGTA,AnByDA,Ac1CA,AGTA,ACHA,AENA,AT2BA;AHUA,AKfA,AGTA,AGTA,AENA,ArB+DA,Ac1CA,AGTA,ACHA,AENA,AT2BA;AHUA,AKfA,AGTA,AGTA,AENA,ArB+DA,Ac1CA,AGTA,ACHA,AENA,AT2BA;AHUA,AKfA,AGTA,AGTA,AENA,ArB+DA,Ac1CA,AGTA,ACHA,AENA,AT2BA;AHUA,AKfA,AGTA,AGTA,AENA,ACHA,AtBkEA,Ac1CA,AGTA,ACHA,AENA,AT2BA;AHUA,AKfA,AGTA,AGTA,AENA,ACHA,AtBkEA,Ac1CA,AIZA,AENA,AT2BA;AHUA,AKfA,AGTA,AGTA,AENA,ACHA,AtBkEA,Ac1CA,AIZA,AENA,AT2BA;AHUA,AKfA,AGTA,AGTA,AENA,AENA,ADGA,AtBkEA,Ac1CA,AIZA,AENA,AT2BA;AHUA,AKfA,AMlBA,AENA,AENA,ADGA,AtBkEA,Ac1CA,AIZA,APqBA;AHUA,AKfA,AMlBA,AENA,AENA,ADGA,AtBkEA,Ac1CA,AIZA,APqBA;AHUA,AKfA,AMlBA,AENA,AENA,ADGA,AENA,AxBwEA,Ac1CA,AIZA,APqBA;AHUA,AKfA,AMlBA,AENA,AENA,ADGA,AENA,AxBwEA,AkBtDA,APqBA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,ANkBA,APqBA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,ACHA,APqBA,APqBA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,ACHA,APqBA,APqBA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,ACHA,APqBA,APqBA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,ACHA,APqBA,AQxBA,Af6CA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,ACHA,APqBA,AQxBA,Af6CA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,ACHA,APqBA,AQxBA,Af6CA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,AGTA,AFMA,APqBA,AQxBA,Af6CA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,AGTA,AFMA,APqBA,AQxBA,Af6CA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,AGTA,AFMA,APqBA,AQxBA,Af6CA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,AGTA,AFMA,AGTA,AV8BA,AQxBA,Af6CA;AHUA,AKfA,AMlBA,AIZA,ADGA,AENA,AGTA,AFMA,AGTA,AV8BA,AQxBA,Af6CA;AHUA,AWjCA,AIZA,ADGA,AENA,AGTA,AFMA,AGTA,AV8BA,AQxBA,Af6CA;AHUA,AWjCA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,ADGA,AV8BA,AQxBA,Af6CA;AHUA,AWjCA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,ADGA,AV8BA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,ADGA,AV8BA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,ADGA,AENA,AZoCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,ADGA,AENA,AZoCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,ADGA,AENA,AZoCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,ADGA,AENA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,ADGA,AENA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,ACHA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,AGTA,AFMA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,AGTA,AFMA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,AGTA,AFMA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,AGTA,ACHA,AHSA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,AGTA,ACHA,AHSA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,AGTA,ACHA,AHSA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,AGTA,ACHA,ACHA,AJYA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,AGTA,ACHA,ACHA,AJYA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,AGTA,ACHA,ACHA,AJYA,ACHA,AbuCA,AQxBA,Af6CA;AQvBA,AIZA,ADGA,AENA,AGTA,AFMA,AIZA,AGTA,ACHA,ACHA,AJYA,ACHA,AIZA,AjBmDA,APqBA;AYnCA,ADGA,AENA,AGTA,AFMA,AIZA,AGTA,ACHA,ACHA,AHSA,AIZA,AjBmDA,APqBA;AWhCA,AENA,AGTA,AFMA,AIZA,AGTA,AENA,AHSA,AIZA,AjBmDA,APqBA;AWhCA,AENA,AGTA,AFMA,AIZA,AGTA,AENA,AENA,ALeA,AIZA,AjBmDA,APqBA;AWhCA,AENA,AGTA,AFMA,AIZA,AKfA,AENA,ALeA,AIZA,AjBmDA,APqBA;AWhCA,AENA,AGTA,AFMA,AIZA,AKfA,AENA,ALeA,AIZA,AjBmDA,APqBA;AWhCA,AENA,AGTA,AFMA,AIZA,AKfA,AENA,ACHA,ANkBA,AIZA,AjBmDA,APqBA;AWhCA,AENA,AGTA,AFMA,AIZA,AKfA,AENA,ACHA,ANkBA,AIZA,AxBwEA;AWhCA,AENA,AGTA,AFMA,AIZA,AKfA,AENA,ACHA,AFMA,AxBwEA;AWhCA,AENA,AGTA,AFMA,AIZA,AKfA,AENA,ACHA,ACHA,AHSA,AxBwEA;AWhCA,AENA,AGTA,AFMA,AIZA,AKfA,AENA,ACHA,ACHA,AHSA,AxBwEA;AWhCA,AENA,AGTA,AFMA,AIZA,AKfA,AGTA,ACHA,AHSA,AxBwEA;AWhCA,AENA,AGTA,AFMA,AIZA,AKfA,AGTA,ACHA,ACHA,AJYA,AxBwEA;AWhCA,AENA,AGTA,AFMA,AIZA,AKfA,AGTA,ACHA,ACHA,AJYA,AxBwEA;AWhCA,AENA,AGTA,AFMA,AIZA,AKfA,AGTA,ACHA,ACHA,AJYA,AxBwEA;AatCA,ACHA,AIZA,AKfA,AGTA,AGTA,AFMA,ACHA,AJYA,AxBwEA;AatCA,ACHA,AIZA,AKfA,AGTA,AGTA,AFMA,ACHA,A5BoFA;AatCA,ACHA,AIZA,AKfA,AGTA,AGTA,AFMA,ACHA,A5BoFA;AatCA,ACHA,AIZA,AKfA,AGTA,AGTA,ACHA,AHSA,ACHA,A5BoFA;AatCA,ACHA,AIZA,AQxBA,AGTA,ACHA,AHSA,ACHA,A5BoFA;AatCA,ACHA,AIZA,AQxBA,AGTA,ACHA,AHSA,ACHA,A5BoFA;AatCA,ACHA,AIZA,AWjCA,ACHA,AHSA,ACHA,A5BoFA;AatCA,ACHA,AIZA,AWjCA,ACHA,AHSA,ACHA,A5BoFA;AatCA,ACHA,AIZA,AWjCA,ACHA,AHSA,ACHA,A5BoFA;AatCA,ACHA,AIZA,AWjCA,ACHA,AHSA,ACHA,A5BoFA;AatCA,ACHA,AIZA,AWjCA,ACHA,AFMA,A5BoFA;AatCA,ACHA,AIZA,AWjCA,ACHA,AFMA,A5BoFA;AatCA,ACHA,AIZA,AWjCA,ACHA,AFMA,A5BoFA;AatCA,ACHA,AIZA,AWjCA,ACHA,A9B0FA;AatCA,ACHA,AIZA,AWjCA,ACHA,A9B0FA;AatCA,ACHA,Ae7CA,ACHA,A9B0FA;AatCA,ACHA,Ae7CA,ACHA,A9B0FA;AatCA,ACHA,Ae7CA,ACHA,A9B0FA;AatCA,ACHA,Ae7CA,ACHA,A9B0FA;AatCA,ACHA,Ae7CA,ACHA,A9B0FA;AatCA,ACHA,Ae7CA,ACHA,A9B0FA;AatCA,ACHA,Ae7CA,ACHA,A9B0FA;AczCA,Ae7CA,ACHA,A9B0FA;AczCA,Ae7CA,ACHA,A9B0FA;AczCA,Ae7CA,ACHA,A9B0FA;AczCA,Ae7CA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A6BtFA,ACHA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA,A9B0FA;A8BzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./lib')\n","module.exports = toMarkdown\n\nvar zwitch = require('zwitch')\nvar configure = require('./configure')\nvar defaultHandlers = require('./handle')\nvar defaultJoin = require('./join')\nvar defaultUnsafe = require('./unsafe')\n\nfunction toMarkdown(tree, options) {\n  var settings = options || {}\n  var context = {\n    enter: enter,\n    stack: [],\n    unsafe: [],\n    join: [],\n    handlers: {},\n    options: {}\n  }\n  var result\n\n  configure(context, {\n    unsafe: defaultUnsafe,\n    join: defaultJoin,\n    handlers: defaultHandlers\n  })\n  configure(context, settings)\n\n  if (context.options.tightDefinitions) {\n    context.join = [joinDefinition].concat(context.join)\n  }\n\n  context.handle = zwitch('type', {\n    invalid: invalid,\n    unknown: unknown,\n    handlers: context.handlers\n  })\n\n  result = context.handle(tree, null, context, {before: '\\n', after: '\\n'})\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  function enter(name) {\n    context.stack.push(name)\n    return exit\n\n    function exit() {\n      context.stack.pop()\n    }\n  }\n}\n\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\nfunction unknown(node) {\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n","module.exports = configure\n\nfunction configure(base, extension) {\n  var index = -1\n  var key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (key === 'extensions') {\n      // Empty.\n    } else if (key === 'unsafe' || key === 'join') {\n      base[key] = base[key].concat(extension[key] || [])\n    } else if (key === 'handlers') {\n      base[key] = Object.assign(base[key], extension[key] || {})\n    } else {\n      base.options[key] = extension[key]\n    }\n  }\n\n  return base\n}\n","exports.blockquote = require('./blockquote')\nexports.break = require('./break')\nexports.code = require('./code')\nexports.definition = require('./definition')\nexports.emphasis = require('./emphasis')\nexports.hardBreak = require('./break')\nexports.heading = require('./heading')\nexports.html = require('./html')\nexports.image = require('./image')\nexports.imageReference = require('./image-reference')\nexports.inlineCode = require('./inline-code')\nexports.link = require('./link')\nexports.linkReference = require('./link-reference')\nexports.list = require('./list')\nexports.listItem = require('./list-item')\nexports.paragraph = require('./paragraph')\nexports.root = require('./root')\nexports.strong = require('./strong')\nexports.text = require('./text')\nexports.thematicBreak = require('./thematic-break')\n","module.exports = blockquote\n\nvar flow = require('../util/container-flow')\nvar indentLines = require('../util/indent-lines')\n\nfunction blockquote(node, _, context) {\n  var exit = context.enter('blockquote')\n  var value = indentLines(flow(node, context), map)\n  exit()\n  return value\n}\n\nfunction map(line, index, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n","module.exports = flow\n\nvar repeat = require('repeat-string')\n\nfunction flow(parent, context) {\n  var children = parent.children || []\n  var results = []\n  var index = -1\n  var child\n\n  while (++index < children.length) {\n    child = children[index]\n\n    results.push(\n      context.handle(child, parent, context, {before: '\\n', after: '\\n'})\n    )\n\n    if (index + 1 < children.length) {\n      results.push(between(child, children[index + 1]))\n    }\n  }\n\n  return results.join('')\n\n  function between(left, right) {\n    var index = -1\n    var result\n\n    while (++index < context.join.length) {\n      result = context.join[index](left, right, parent, context)\n\n      if (result === true || result === 1) {\n        break\n      }\n\n      if (typeof result === 'number') {\n        return repeat('\\n', 1 + Number(result))\n      }\n\n      if (result === false) {\n        return '\\n\\n<!---->\\n\\n'\n      }\n    }\n\n    return '\\n\\n'\n  }\n}\n","module.exports = indentLines\n\nvar eol = /\\r?\\n|\\r/g\n\nfunction indentLines(value, map) {\n  var result = []\n  var start = 0\n  var line = 0\n  var match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","module.exports = hardBreak\n\nvar patternInScope = require('../util/pattern-in-scope')\n\nfunction hardBreak(node, _, context, safe) {\n  var index = -1\n\n  while (++index < context.unsafe.length) {\n    // If we can’t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      context.unsafe[index].character === '\\n' &&\n      patternInScope(context.stack, context.unsafe[index])\n    ) {\n      return /[ \\t]/.test(safe.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n","module.exports = patternInScope\n\nfunction patternInScope(stack, pattern) {\n  return (\n    listInScope(stack, pattern.inConstruct, true) &&\n    !listInScope(stack, pattern.notInConstruct)\n  )\n}\n\nfunction listInScope(stack, list, none) {\n  var index\n\n  if (!list) {\n    return none\n  }\n\n  if (typeof list === 'string') {\n    list = [list]\n  }\n\n  index = -1\n\n  while (++index < list.length) {\n    if (stack.indexOf(list[index]) !== -1) {\n      return true\n    }\n  }\n\n  return false\n}\n","module.exports = code\n\nvar repeat = require('repeat-string')\nvar streak = require('longest-streak')\nvar formatCodeAsIndented = require('../util/format-code-as-indented')\nvar checkFence = require('../util/check-fence')\nvar indentLines = require('../util/indent-lines')\nvar safe = require('../util/safe')\n\nfunction code(node, _, context) {\n  var marker = checkFence(context)\n  var raw = node.value || ''\n  var suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n  var value\n  var sequence\n  var exit\n  var subexit\n\n  if (formatCodeAsIndented(node, context)) {\n    exit = context.enter('codeIndented')\n    value = indentLines(raw, map)\n  } else {\n    sequence = repeat(marker, Math.max(streak(raw, marker) + 1, 3))\n    exit = context.enter('codeFenced')\n    value = sequence\n\n    if (node.lang) {\n      subexit = context.enter('codeFencedLang' + suffix)\n      value += safe(context, node.lang, {\n        before: '`',\n        after: ' ',\n        encode: ['`']\n      })\n      subexit()\n    }\n\n    if (node.lang && node.meta) {\n      subexit = context.enter('codeFencedMeta' + suffix)\n      value +=\n        ' ' +\n        safe(context, node.meta, {\n          before: ' ',\n          after: '\\n',\n          encode: ['`']\n        })\n      subexit()\n    }\n\n    value += '\\n'\n\n    if (raw) {\n      value += raw + '\\n'\n    }\n\n    value += sequence\n  }\n\n  exit()\n  return value\n}\n\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n","module.exports = formatCodeAsIndented\n\nfunction formatCodeAsIndented(node, context) {\n  return (\n    !context.options.fences &&\n    node.value &&\n    // If there’s no info…\n    !node.lang &&\n    // And there’s a non-whitespace character…\n    /[^ \\r\\n]/.test(node.value) &&\n    // And the value doesn’t start or end in a blank…\n    !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n","module.exports = checkFence\n\nfunction checkFence(context) {\n  var marker = context.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n","module.exports = safe\n\nvar patternCompile = require('./pattern-compile')\nvar patternInScope = require('./pattern-in-scope')\n\nfunction safe(context, input, config) {\n  var value = (config.before || '') + (input || '') + (config.after || '')\n  var positions = []\n  var result = []\n  var infos = {}\n  var index = -1\n  var before\n  var after\n  var position\n  var pattern\n  var expression\n  var match\n  var start\n  var end\n\n  while (++index < context.unsafe.length) {\n    pattern = context.unsafe[index]\n\n    if (!patternInScope(context.stack, pattern)) {\n      continue\n    }\n\n    expression = patternCompile(pattern)\n\n    while ((match = expression.exec(value))) {\n      before = 'before' in pattern || pattern.atBreak\n      after = 'after' in pattern\n\n      position = match.index + (before ? match[1].length : 0)\n\n      if (positions.indexOf(position) === -1) {\n        positions.push(position)\n        infos[position] = {before: before, after: after}\n      } else {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  start = config.before ? config.before.length : 0\n  end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    position = positions[index]\n\n    if (\n      // Character before or after matched:\n      position < start ||\n      position >= end\n    ) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      position + 1 < end &&\n      positions[index + 1] === position + 1 &&\n      infos[position].after &&\n      !infos[position + 1].before &&\n      !infos[position + 1].after\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || config.encode.indexOf(value.charAt(position)) === -1)\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\nfunction numerical(a, b) {\n  return a - b\n}\n\nfunction escapeBackslashes(value, after) {\n  var expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  var positions = []\n  var results = []\n  var index = -1\n  var start = 0\n  var whole = value + after\n  var match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","module.exports = patternCompile\n\nfunction patternCompile(pattern) {\n  var before\n  var after\n\n  if (!pattern._compiled) {\n    before = pattern.before ? '(?:' + pattern.before + ')' : ''\n    after = pattern.after ? '(?:' + pattern.after + ')' : ''\n\n    if (pattern.atBreak) {\n      before = '[\\\\r\\\\n][\\\\t ]*' + before\n    }\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (after || ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","module.exports = definition\n\nvar association = require('../util/association')\nvar checkQuote = require('../util/check-quote')\nvar safe = require('../util/safe')\n\nfunction definition(node, _, context) {\n  var marker = checkQuote(context)\n  var suffix = marker === '\"' ? 'Quote' : 'Apostrophe'\n  var exit = context.enter('definition')\n  var subexit = context.enter('label')\n  var value =\n    '[' + safe(context, association(node), {before: '[', after: ']'}) + ']: '\n\n  subexit()\n\n  if (\n    // If there’s no url, or…\n    !node.url ||\n    // If there’s whitespace, enclosed is prettier.\n    /[ \\t\\r\\n]/.test(node.url)\n  ) {\n    subexit = context.enter('destinationLiteral')\n    value += '<' + safe(context, node.url, {before: '<', after: '>'}) + '>'\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = context.enter('destinationRaw')\n    value += safe(context, node.url, {before: ' ', after: ' '})\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = context.enter('title' + suffix)\n    value +=\n      ' ' +\n      marker +\n      safe(context, node.title, {before: marker, after: marker}) +\n      marker\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n","module.exports = association\n\nvar decode = require('parse-entities/decode-entity')\n\nvar characterEscape = /\\\\([!-/:-@[-`{-~])/g\nvar characterReference = /&(#(\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi\n\n// The `label` of an association is the string value: character escapes and\n// references work, and casing is intact.\n// The `identifier` is used to match one association to another: controversially,\n// character escapes and references don’t work in this matching: `&copy;` does\n// not match `©`, and `\\+` does not match `+`.\n// But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n// matches `a b`.\n// So, we do prefer the label when figuring out how we’re going to serialize:\n// it has whitespace, casing, and we can ignore most useless character escapes\n// and all character references.\nfunction association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return node.identifier\n    .replace(characterEscape, '$1')\n    .replace(characterReference, decodeIfPossible)\n}\n\nfunction decodeIfPossible($0, $1) {\n  return decode($1) || $0\n}\n","module.exports = checkQuote\n\nfunction checkQuote(context) {\n  var marker = context.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n","module.exports = emphasis\nemphasis.peek = emphasisPeek\n\nvar checkEmphasis = require('../util/check-emphasis')\nvar phrasing = require('../util/container-phrasing')\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\nfunction emphasis(node, _, context) {\n  var marker = checkEmphasis(context)\n  var exit = context.enter('emphasis')\n  var value = phrasing(node, context, {before: marker, after: marker})\n  exit()\n  return marker + value + marker\n}\n\nfunction emphasisPeek(node, _, context) {\n  return context.options.emphasis || '*'\n}\n","module.exports = checkEmphasis\n\nfunction checkEmphasis(context) {\n  var marker = context.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","module.exports = phrasing\n\nfunction phrasing(parent, context, safeOptions) {\n  var children = parent.children || []\n  var results = []\n  var index = -1\n  var before = safeOptions.before\n  var after\n  var handle\n  var child\n\n  while (++index < children.length) {\n    child = children[index]\n\n    if (index + 1 < children.length) {\n      handle = context.handle.handlers[children[index + 1].type]\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, context, {\n            before: '',\n            after: ''\n          }).charAt(0)\n        : ''\n    } else {\n      after = safeOptions.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n    }\n\n    results.push(\n      context.handle(child, parent, context, {\n        before: before,\n        after: after\n      })\n    )\n\n    before = results[results.length - 1].slice(-1)\n  }\n\n  return results.join('')\n}\n","module.exports = heading\n\nvar repeat = require('repeat-string')\nvar formatHeadingAsSetext = require('../util/format-heading-as-setext')\nvar phrasing = require('../util/container-phrasing')\n\nfunction heading(node, _, context) {\n  var rank = Math.max(Math.min(6, node.depth || 1), 1)\n  var exit\n  var subexit\n  var value\n  var sequence\n\n  if (formatHeadingAsSetext(node, context)) {\n    exit = context.enter('headingSetext')\n    subexit = context.enter('phrasing')\n    value = phrasing(node, context, {before: '\\n', after: '\\n'})\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      repeat(\n        rank === 1 ? '=' : '-',\n        // The whole size…\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)…\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  sequence = repeat('#', rank)\n  exit = context.enter('headingAtx')\n  subexit = context.enter('phrasing')\n  value = phrasing(node, context, {before: '# ', after: '\\n'})\n  value = value ? sequence + ' ' + value : sequence\n  if (context.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n","module.exports = formatHeadingAsSetext\n\nvar toString = require('mdast-util-to-string')\n\nfunction formatHeadingAsSetext(node, context) {\n  return (\n    context.options.setext && (!node.depth || node.depth < 3) && toString(node)\n  )\n}\n","module.exports = html\nhtml.peek = htmlPeek\n\nfunction html(node) {\n  return node.value || ''\n}\n\nfunction htmlPeek() {\n  return '<'\n}\n","module.exports = image\nimage.peek = imagePeek\n\nvar checkQuote = require('../util/check-quote')\nvar safe = require('../util/safe')\n\nfunction image(node, _, context) {\n  var quote = checkQuote(context)\n  var suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  var exit = context.enter('image')\n  var subexit = context.enter('label')\n  var value = '![' + safe(context, node.alt, {before: '[', after: ']'}) + ']('\n\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // Or if there’s markdown whitespace or an eol, enclose.\n    /[ \\t\\r\\n]/.test(node.url)\n  ) {\n    subexit = context.enter('destinationLiteral')\n    value += '<' + safe(context, node.url, {before: '<', after: '>'}) + '>'\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = context.enter('destinationRaw')\n    value += safe(context, node.url, {\n      before: '(',\n      after: node.title ? ' ' : ')'\n    })\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = context.enter('title' + suffix)\n    value +=\n      ' ' +\n      quote +\n      safe(context, node.title, {before: quote, after: quote}) +\n      quote\n    subexit()\n  }\n\n  value += ')'\n  exit()\n\n  return value\n}\n\nfunction imagePeek() {\n  return '!'\n}\n","module.exports = imageReference\nimageReference.peek = imageReferencePeek\n\nvar association = require('../util/association')\nvar safe = require('../util/safe')\n\nfunction imageReference(node, _, context) {\n  var type = node.referenceType\n  var exit = context.enter('imageReference')\n  var subexit = context.enter('label')\n  var alt = safe(context, node.alt, {before: '[', after: ']'})\n  var value = '![' + alt + ']'\n  var reference\n  var stack\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  stack = context.stack\n  context.stack = []\n  subexit = context.enter('reference')\n  reference = safe(context, association(node), {before: '[', after: ']'})\n  subexit()\n  context.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += '[' + reference + ']'\n  } else if (type !== 'shortcut') {\n    value += '[]'\n  }\n\n  return value\n}\n\nfunction imageReferencePeek() {\n  return '!'\n}\n","module.exports = inlineCode\ninlineCode.peek = inlineCodePeek\n\nvar patternCompile = require('../util/pattern-compile')\n\nfunction inlineCode(node, parent, context) {\n  var value = node.value || ''\n  var sequence = '`'\n  var index = -1\n  var pattern\n  var expression\n  var match\n  var position\n\n  // If there is a single grave accent on its own in the code, use a fence of\n  // two.\n  // If there are two in a row, use one.\n  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {\n    sequence += '`'\n  }\n\n  // If this is not just spaces or eols (tabs don’t count), and either the\n  // first or last character are a space, eol, or tick, then pad with spaces.\n  if (\n    /[^ \\r\\n]/.test(value) &&\n    (/[ \\r\\n`]/.test(value.charAt(0)) ||\n      /[ \\r\\n`]/.test(value.charAt(value.length - 1)))\n  ) {\n    value = ' ' + value + ' '\n  }\n\n  // We have a potential problem: certain characters after eols could result in\n  // blocks being seen.\n  // For example, if someone injected the string `'\\n# b'`, then that would\n  // result in an ATX heading.\n  // We can’t escape characters in `inlineCode`, but because eols are\n  // transformed to spaces when going from markdown to HTML anyway, we can swap\n  // them out.\n  while (++index < context.unsafe.length) {\n    pattern = context.unsafe[index]\n\n    // Only look for `atBreak`s.\n    // Btw: note that `atBreak` patterns will always start the regex at LF or\n    // CR.\n    if (!pattern.atBreak) continue\n\n    expression = patternCompile(pattern)\n\n    while ((match = expression.exec(value))) {\n      position = match.index\n\n      // Support CRLF (patterns only look for one of the characters).\n      if (\n        value.charCodeAt(position) === 10 /* `\\n` */ &&\n        value.charCodeAt(position - 1) === 13 /* `\\r` */\n      ) {\n        position--\n      }\n\n      value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\n    }\n  }\n\n  return sequence + value + sequence\n}\n\nfunction inlineCodePeek() {\n  return '`'\n}\n","module.exports = link\nlink.peek = linkPeek\n\nvar checkQuote = require('../util/check-quote')\nvar formatLinkAsAutolink = require('../util/format-link-as-autolink')\nvar phrasing = require('../util/container-phrasing')\nvar safe = require('../util/safe')\n\nfunction link(node, _, context) {\n  var quote = checkQuote(context)\n  var suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  var exit\n  var subexit\n  var value\n  var stack\n\n  if (formatLinkAsAutolink(node, context)) {\n    // Hide the fact that we’re in phrasing, because escapes don’t work.\n    stack = context.stack\n    context.stack = []\n    exit = context.enter('autolink')\n    value = '<' + phrasing(node, context, {before: '<', after: '>'}) + '>'\n    exit()\n    context.stack = stack\n    return value\n  }\n\n  exit = context.enter('link')\n  subexit = context.enter('label')\n  value = '[' + phrasing(node, context, {before: '[', after: ']'}) + ']('\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // Or if there’s markdown whitespace or an eol, enclose.\n    /[ \\t\\r\\n]/.test(node.url)\n  ) {\n    subexit = context.enter('destinationLiteral')\n    value += '<' + safe(context, node.url, {before: '<', after: '>'}) + '>'\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = context.enter('destinationRaw')\n    value += safe(context, node.url, {\n      before: '(',\n      after: node.title ? ' ' : ')'\n    })\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = context.enter('title' + suffix)\n    value +=\n      ' ' +\n      quote +\n      safe(context, node.title, {before: quote, after: quote}) +\n      quote\n    subexit()\n  }\n\n  value += ')'\n\n  exit()\n  return value\n}\n\nfunction linkPeek(node, _, context) {\n  return formatLinkAsAutolink(node, context) ? '<' : '['\n}\n","module.exports = formatLinkAsAutolink\n\nvar toString = require('mdast-util-to-string')\n\nfunction formatLinkAsAutolink(node, context) {\n  var raw = toString(node)\n\n  return (\n    !context.options.resourceLink &&\n    // If there’s a url…\n    node.url &&\n    // And there’s a no title…\n    !node.title &&\n    // And the content of `node` is a single text node…\n    node.children &&\n    node.children.length === 1 &&\n    node.children[0].type === 'text' &&\n    // And if the url is the same as the content…\n    (raw === node.url || 'mailto:' + raw === node.url) &&\n    // And that starts w/ a protocol…\n    /^[a-z][a-z+.-]+:/i.test(node.url) &&\n    // And that doesn’t contain ASCII control codes (character escapes and\n    // references don’t work) or angle brackets…\n    !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n","module.exports = linkReference\nlinkReference.peek = linkReferencePeek\n\nvar association = require('../util/association')\nvar phrasing = require('../util/container-phrasing')\nvar safe = require('../util/safe')\n\nfunction linkReference(node, _, context) {\n  var type = node.referenceType\n  var exit = context.enter('linkReference')\n  var subexit = context.enter('label')\n  var text = phrasing(node, context, {before: '[', after: ']'})\n  var value = '[' + text + ']'\n  var reference\n  var stack\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  stack = context.stack\n  context.stack = []\n  subexit = context.enter('reference')\n  reference = safe(context, association(node), {before: '[', after: ']'})\n  subexit()\n  context.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += '[' + reference + ']'\n  } else if (type !== 'shortcut') {\n    value += '[]'\n  }\n\n  return value\n}\n\nfunction linkReferencePeek() {\n  return '['\n}\n","module.exports = list\n\nvar flow = require('../util/container-flow')\n\nfunction list(node, _, context) {\n  var exit = context.enter('list')\n  var value = flow(node, context)\n  exit()\n  return value\n}\n","module.exports = listItem\n\nvar repeat = require('repeat-string')\nvar checkBullet = require('../util/check-bullet')\nvar checkListItemIndent = require('../util/check-list-item-indent')\nvar flow = require('../util/container-flow')\nvar indentLines = require('../util/indent-lines')\n\nfunction listItem(node, parent, context) {\n  var bullet = checkBullet(context)\n  var listItemIndent = checkListItemIndent(context)\n  var size\n  var value\n  var exit\n\n  if (parent && parent.ordered) {\n    bullet =\n      (parent.start > -1 ? parent.start : 1) +\n      (context.options.incrementListMarker === false\n        ? 0\n        : parent.children.indexOf(node)) +\n      '.'\n  }\n\n  size = bullet.length + 1\n\n  if (\n    listItemIndent === 'tab' ||\n    (listItemIndent === 'mixed' && ((parent && parent.spread) || node.spread))\n  ) {\n    size = Math.ceil(size / 4) * 4\n  }\n\n  exit = context.enter('listItem')\n  value = indentLines(flow(node, context), map)\n  exit()\n\n  return value\n\n  function map(line, index, blank) {\n    if (index) {\n      return (blank ? '' : repeat(' ', size)) + line\n    }\n\n    return (blank ? bullet : bullet + repeat(' ', size - bullet.length)) + line\n  }\n}\n","module.exports = checkBullet\n\nfunction checkBullet(context) {\n  var marker = context.options.bullet || '*'\n\n  if (marker !== '*' && marker !== '+' && marker !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bullet`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  return marker\n}\n","module.exports = checkListItemIndent\n\nfunction checkListItemIndent(context) {\n  var style = context.options.listItemIndent || 'tab'\n\n  if (style === 1 || style === '1') {\n    return 'one'\n  }\n\n  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        style +\n        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'\n    )\n  }\n\n  return style\n}\n","module.exports = paragraph\n\nvar phrasing = require('../util/container-phrasing')\n\nfunction paragraph(node, _, context) {\n  var exit = context.enter('paragraph')\n  var subexit = context.enter('phrasing')\n  var value = phrasing(node, context, {before: '\\n', after: '\\n'})\n  subexit()\n  exit()\n  return value\n}\n","module.exports = root\n\nvar flow = require('../util/container-flow')\n\nfunction root(node, _, context) {\n  return flow(node, context)\n}\n","module.exports = strong\nstrong.peek = strongPeek\n\nvar checkStrong = require('../util/check-strong')\nvar phrasing = require('../util/container-phrasing')\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\nfunction strong(node, _, context) {\n  var marker = checkStrong(context)\n  var exit = context.enter('strong')\n  var value = phrasing(node, context, {before: marker, after: marker})\n  exit()\n  return marker + marker + value + marker + marker\n}\n\nfunction strongPeek(node, _, context) {\n  return context.options.strong || '*'\n}\n","module.exports = checkStrong\n\nfunction checkStrong(context) {\n  var marker = context.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n","module.exports = text\n\nvar safe = require('../util/safe')\n\nfunction text(node, parent, context, safeOptions) {\n  return safe(context, node.value, safeOptions)\n}\n","module.exports = thematicBreak\n\nvar repeat = require('repeat-string')\nvar checkRepeat = require('../util/check-rule-repeat')\nvar checkRule = require('../util/check-rule')\n\nfunction thematicBreak(node, parent, context) {\n  var value = repeat(\n    checkRule(context) + (context.options.ruleSpaces ? ' ' : ''),\n    checkRepeat(context)\n  )\n\n  return context.options.ruleSpaces ? value.slice(0, -1) : value\n}\n","module.exports = checkRule\n\nfunction checkRule(context) {\n  var repetition = context.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n","module.exports = checkRule\n\nfunction checkRule(context) {\n  var marker = context.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n","module.exports = [joinDefaults]\n\nvar formatCodeAsIndented = require('./util/format-code-as-indented')\nvar formatHeadingAsSetext = require('./util/format-heading-as-setext')\n\nfunction joinDefaults(left, right, parent, context) {\n  if (\n    // Two lists with the same marker.\n    (right.type === 'list' &&\n      right.type === left.type &&\n      Boolean(left.ordered) === Boolean(right.ordered)) ||\n    // Indented code after list or another indented code.\n    (right.type === 'code' &&\n      formatCodeAsIndented(right, context) &&\n      (left.type === 'list' ||\n        (left.type === right.type && formatCodeAsIndented(left, context))))\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if (typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, context)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","module.exports = [\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {character: '!', after: '\\\\[', inConstruct: 'phrasing'},\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  {before: '\\\\]', character: '(', inConstruct: 'phrasing'},\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*'},\n  {character: '*', inConstruct: 'phrasing'},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {character: '<', after: '[!/?A-Za-z]', inConstruct: 'phrasing'},\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: ['phrasing', 'label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {\n    character: ']',\n    inConstruct: ['label', 'reference']\n  },\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {before: '[^A-Za-z]', character: '_', inConstruct: 'phrasing'},\n  {character: '_', after: '[^A-Za-z]', inConstruct: 'phrasing'},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedMetaGraveAccent',\n      'phrasing'\n    ]\n  },\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n"]}