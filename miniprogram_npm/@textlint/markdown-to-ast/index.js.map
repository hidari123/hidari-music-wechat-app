{"version":3,"sources":["index.js","mapping/markdown-syntax-map.js","parse-markdown.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = exports.Syntax = void 0;\nconst markdown_syntax_map_1 = require(\"./mapping/markdown-syntax-map\");\nconst ast_node_types_1 = require(\"@textlint/ast-node-types\");\nObject.defineProperty(exports, \"Syntax\", { enumerable: true, get: function () { return ast_node_types_1.ASTNodeTypes; } });\nconst traverse_1 = __importDefault(require(\"traverse\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst parse_markdown_1 = require(\"./parse-markdown\");\nconst debug = (0, debug_1.default)(\"@textlint/markdown-to-ast\");\n/**\n * parse markdown text and return ast mapped location info.\n * @param {string} text\n * @returns {TxtNode}\n */\nfunction parse(text) {\n    // remark-parse's AST does not consider BOM\n    // AST's position does not +1 by BOM\n    // So, just trim BOM and parse it for `raw` property\n    // textlint's SourceCode also take same approach - trim BOM and check the position\n    // This means that the loading side need to consider BOM position - for example fs.readFile and text slice script.\n    // https://github.com/micromark/micromark/blob/0f19c1ac25964872a160d8b536878b125ddfe393/lib/preprocess.mjs#L29-L31\n    const hasBOM = text.charCodeAt(0) === 0xfeff;\n    const textWithoutBOM = hasBOM ? text.slice(1) : text;\n    const ast = (0, parse_markdown_1.parseMarkdown)(textWithoutBOM);\n    (0, traverse_1.default)(ast).forEach(function (node) {\n        // eslint-disable-next-line no-invalid-this\n        if (this.notLeaf) {\n            if (node.type) {\n                const replacedType = markdown_syntax_map_1.SyntaxMap[node.type];\n                if (!replacedType) {\n                    debug(`replacedType : ${replacedType} , node.type: ${node.type}`);\n                }\n                else {\n                    node.type = replacedType;\n                }\n            }\n            // map `range`, `loc` and `raw` to node\n            if (node.position) {\n                const position = node.position;\n                const positionCompensated = {\n                    start: { line: position.start.line, column: Math.max(position.start.column - 1, 0) },\n                    end: { line: position.end.line, column: Math.max(position.end.column - 1, 0) }\n                };\n                const range = [position.start.offset, position.end.offset];\n                node.loc = positionCompensated;\n                node.range = range;\n                node.raw = textWithoutBOM.slice(range[0], range[1]);\n                // Compatible for https://github.com/syntax-tree/unist, but it is hidden\n                Object.defineProperty(node, \"position\", {\n                    enumerable: false,\n                    configurable: false,\n                    writable: false,\n                    value: position\n                });\n            }\n        }\n    });\n    return ast;\n}\nexports.parse = parse;\n//# sourceMappingURL=index.js.map","// LICENSE : MIT\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyntaxMap = void 0;\nconst ast_node_types_1 = require(\"@textlint/ast-node-types\");\nexports.SyntaxMap = {\n    root: ast_node_types_1.ASTNodeTypes.Document,\n    paragraph: ast_node_types_1.ASTNodeTypes.Paragraph,\n    blockquote: ast_node_types_1.ASTNodeTypes.BlockQuote,\n    listItem: ast_node_types_1.ASTNodeTypes.ListItem,\n    list: ast_node_types_1.ASTNodeTypes.List,\n    Bullet: \"Bullet\",\n    heading: ast_node_types_1.ASTNodeTypes.Header,\n    code: ast_node_types_1.ASTNodeTypes.CodeBlock,\n    HtmlBlock: ast_node_types_1.ASTNodeTypes.HtmlBlock,\n    thematicBreak: ast_node_types_1.ASTNodeTypes.HorizontalRule,\n    // inline block\n    text: ast_node_types_1.ASTNodeTypes.Str,\n    break: ast_node_types_1.ASTNodeTypes.Break,\n    emphasis: ast_node_types_1.ASTNodeTypes.Emphasis,\n    strong: ast_node_types_1.ASTNodeTypes.Strong,\n    html: ast_node_types_1.ASTNodeTypes.Html,\n    link: ast_node_types_1.ASTNodeTypes.Link,\n    image: ast_node_types_1.ASTNodeTypes.Image,\n    inlineCode: ast_node_types_1.ASTNodeTypes.Code,\n    delete: ast_node_types_1.ASTNodeTypes.Delete,\n    // remark(markdown) extension\n    // Following type is not in @textlint/ast-node-types\n    yaml: \"Yaml\",\n    table: \"Table\",\n    tableRow: \"TableRow\",\n    tableCell: \"TableCell\",\n    linkReference: \"LinkReference\",\n    imageReference: \"ImageReference\",\n    footnoteReference: \"FootnoteReference\",\n    definition: \"Definition\",\n    /**\n     * @deprecated\n     */\n    ReferenceDef: ast_node_types_1.ASTNodeTypes.ReferenceDef\n};\n//# sourceMappingURL=markdown-syntax-map.js.map","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseMarkdown = void 0;\nconst unified_1 = __importDefault(require(\"unified\"));\n// @ts-ignore\nconst from_markdown_1 = __importDefault(require(\"mdast-util-gfm-autolink-literal/from-markdown\"));\n// FIXME: Disable auto link literal transforms that break AST node\n// https://github.com/remarkjs/remark-gfm/issues/16\n// Need to override before import gfm plugin\nfrom_markdown_1.default.transforms = [];\n// Load plugins\nconst remark_gfm_1 = __importDefault(require(\"remark-gfm\"));\nconst remark_parse_1 = __importDefault(require(\"remark-parse\"));\nconst remark_frontmatter_1 = __importDefault(require(\"remark-frontmatter\"));\nconst remark_footnotes_1 = __importDefault(require(\"remark-footnotes\"));\nconst remark = (0, unified_1.default)().use(remark_parse_1.default).use(remark_frontmatter_1.default, [\"yaml\"]).use(remark_gfm_1.default).use(remark_footnotes_1.default, {\n    inlineNotes: true\n});\nconst parseMarkdown = (text) => {\n    return remark.parse(text);\n};\nexports.parseMarkdown = parseMarkdown;\n//# sourceMappingURL=parse-markdown.js.map"]}