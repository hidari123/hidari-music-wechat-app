{"version":3,"sources":["update-section.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\n/**\n * Finds the start and end lines that match the given criteria.\n * Used by update-section itself.\n *\n * Use it if you need to get information about where the matching content is located.\n *\n * @name updateSection::parse\n * @function\n * @param {Array.<string>} lines the lines in which to look for matches\n * @param {Function} matchesStart when called with a line needs to return true iff it is the section start line\n * @param {Function} matchesEnd when called with a line needs to return true iff it is the section end line\n * @return {object} with the following properties: hasStart, hasEnd, startIdx, endIdx \n */\nfunction parse(lines, matchesStart, matchesEnd) {\n  var startIdx = -1\n    , endIdx = -1\n    , hasStart = false\n    , hasEnd = false\n    , line;\n\n  for (var i = 0; i < lines.length; i++) {\n    line = lines[i]\n    if (!hasStart && matchesStart(line)) { \n      startIdx = i;\n      hasStart = true;\n    } else if (!hasEnd && matchesEnd(line)) {\n      endIdx = i;\n      hasEnd = true;\n    }\n    if (hasStart && hasEnd) break;\n  }\n\n  // no end, correct it to be all remaining lines after start\n  if (!hasEnd) {\n    endIdx = lines.length;\n    hasEnd = true;\n  }\n\n  return { hasStart: hasStart, hasEnd: hasEnd, startIdx: startIdx, endIdx: endIdx };\n}\n\n/**\n * Updates the content with the given section. \n *\n * If previous section is found it is replaced.\n * Otherwise the section is appended to the end of the content.\n *\n * @name updateSection\n * @function\n * @param {String} content that may or may not include a previously added section\n * @param {String} section the section to update\n * @param {Function} matchesStart when called with a line needs to return true iff it is the section start line\n * @param {Function} matchesEnd when called with a line needs to return true iff it is the section end line\n * @param {boolean} top forces the section to be added at the top of the content if a replacement couldn't be made\n * @return {String} content with updated section\n */\nexports = module.exports = function updateSection(content, section, matchesStart, matchesEnd, top) {\n  if (!content) return section;\n\n  var lines = content.split('\\n')\n  if (!lines.length) return section;\n\n  var info = parse(lines, matchesStart, matchesEnd);\n\n  // no previous section found in content not just append\n  if (!info.hasStart) return top ? section + '\\n\\n' + content : content + '\\n\\n' + section;\n\n  var sectionLines = section.split('\\n')\n    , dropN = info.endIdx - info.startIdx + 1;\n\n  [].splice.apply(lines, [ info.startIdx, dropN ].concat(sectionLines))\n\n  return lines.join('\\n');\n}\n\nexports.parse = parse;\n"]}